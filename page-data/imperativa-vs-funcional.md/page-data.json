{"componentChunkName":"component---src-templates-blog-post-js","path":"/imperativa-vs-funcional.md/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"7cca5c94-5c09-5c58-8026-2dc62f26e384","excerpt":"A alguns dias venho pesquisando sobre paradigmas para um seminário na disciplina de Frameworks, sinceramente,\nexiste muito conteúdo a respeito deles, mas não…","html":"<p>A alguns dias venho pesquisando sobre paradigmas para um seminário na disciplina de Frameworks, sinceramente,\nexiste muito conteúdo a respeito deles, mas não custa nada escrever mais um pouco e com certeza também há que precise\ne goste de alguns resumos como eu.</p>\n<h3>Programação Imperativa vs Programação Funcional</h3>\n<p>Bom, a idéa desse post é clarear um pouco a mente (no sentido de introdução) quanto aos paradigmas imperativos e funcionais.\nNo final da publicação há referências para um estudo mais amplo sobre os paradigmas (dica: o bom estudo em paradigmas de\nprogramação é a prória programação em linguagens de paradigmas distintos e “botar a mão na massa”), aqui, cabe uma concatenação\nde boas explicações que encontrei, juntamente a algumas colocações que eu venho trabalhando.</p>\n<h3>Programação Imperativa</h3>\n<p>A <strong>Programação Imperativa</strong> é o que a maioria dos programadores profissionais usam em seus trabalhos do dia-a-dia.\nÉ o nome dado a linguagens como C, C++, Java, COBOL, etc. Na programação imperativa, você vai dizer ao computador o que fazer.\n“Computador, adicione x e y”, ou “Computador, mostre uma caixa de diálogo na tela.” E (geralmente) o computador vai realizar a terefa.\nEste é o lugar onde a maioria de nós gastamos nossas vidas, em estruturas de loop e declarações if-then-else e afins.</p>\n<h3>Programação Funcional</h3>\n<p>A Programação funcional, tanto quanto eu entendo, procura <strong>descrever o que você quer fazer, em vez de especificar como você quer que seja\nfeito</strong>. É provavelmente melhor entendida em contraste com a programação imperativa.\nPor exemplo, se você tem uma lista em C e você quer retirar todos os enésimos elementos, você tem que apontar para o primeiro elemento,\ndefinir um contador em um, passar para o próximo elemento, incrementar o contador, verificar para ver se você está no enésimo\nelemento e assim por diante. O equivalente funcional seria escrever uma função que reconhece quando o tamanho de uma lista é\num múltiplo de N, em seguida, passar essa função para a lista, possivelmente com um outro trecho de código para devolver a cabeça\nda lista (sentinela) se o enésimo reconhecedor for avaliado como verdadeiro e descartá-lo se for avaliado como falso.\nAs duas funções recursam através da lista, e finalmente, devolve uma lista que consiste em todos os enésimos elementos.</p>\n<p>O último método pode parecer o caminho mais confuso de fazer as coisas, e isso é porque é. A programação funcional pode ser\num mind-bender (frita sua cabeça), que é uma razão pela qual as linguagens funcionais Lisp, Scheme, e Haskell nunca realmente\nsuperaram C, C++, Java e COBOL em popularidade comercial. Mas há benefícios para a forma funcional. Por um lado,\nse você pode obter a lógica correta, <strong>a programação funcional requer ordens de magnitude em menos código que programação imperativa</strong>.\nIsso significa menos pontos de falha, menos código para testar, e uma mais produtiva (e, muitos diriam, mais feliz) vida de programação.\nComo os sistemas ficam maiores, esta tornou-se cada vez mais importante.</p>\n<h2>Resumo</h2>\n<p>Em linguagens imperativas você vai dizer ao computador como alterar os bits, bytes e palavras em sua memória e em que ordem.\nEm linguagens funcionais, você vai dizer ao computador, o que as coisas, ações etc, são. Por exemplo, podemos dizer que o fatorial\nde 0 é 1, e o fatorial de qualquer outro número natural é o produto desse número e o fatorial de seu antecessor. Nós não dizemos:\nPara calcular o fatorial de n, reservar uma região de memória e armazenar 1 lá, em seguida, multiplicar o número naquela região\nde memória com os números 2 a N e armazenar o resultado no mesmo lugar, e no final, a região da memória conterá o fatorial.</p>\n<hr>\n<p><em>Mais? segue…</em></p>\n<ul>\n<li><a href=\"https://pt.wikipedia.org/wiki/The_C_Programming_Language\">K&#x26;R</a></li>\n<li><a href=\"https://mitpress.mit.edu/sicp/\">Wizard Book - SICP</a></li>\n<li><a href=\"http://stackoverflow.com/questions/602444/what-is-functional-declarative-and-imperative-programming\">What is functional declarative and imperative programming language</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=7Zlp9rKHGD4\">Robert C Martin - Functional Programming; What? Why? When?</a></li>\n</ul>","frontmatter":{"title":"Programação Imperativa vs Funcional","date":"March 27, 2016","description":"Paradigmas de Programação: Imperativa ou Funcional?"}},"previous":{"fields":{"slug":"/complexidade-ciclomatica/"},"frontmatter":{"title":"Complexidade Ciclomática"}},"next":{"fields":{"slug":"/sistemas-operacionais-exercicios.md/"},"frontmatter":{"title":"Sistemas Operacionais"}}},"pageContext":{"id":"7cca5c94-5c09-5c58-8026-2dc62f26e384","previousPostId":"1abc4ea3-9fca-5dda-8639-c0715aeaf6c5","nextPostId":"f2c56a05-bc34-5aaf-8e69-2528737d86f6"}},"staticQueryHashes":["2841359383","916993862"]}