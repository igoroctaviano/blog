{"componentChunkName":"component---src-templates-blog-post-js","path":"/complexidade-ciclomatica/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"3bdfad95-35de-5975-a3e8-356b22b3ca7c","excerpt":"Obra de Thomas J. McCabe, ..reflete diretamente o número de caminhos independentes que um programa pode tomar durante a sua execução. Esse post é dedicado aos…","html":"<h3>Obra de Thomas J. McCabe,</h3>\n<p><em>..reflete diretamente o número de caminhos independentes que um programa pode tomar durante a sua execução.</em></p>\n<p>Esse post é dedicado aos colegas da disciplina de <em>Introdução a Testes de Software</em>, mas\nqualquer desenvolvedor que já trabalhou com testes, tem conhecimento de que a quantidade\nde casos de testes necessários para exercitar um determinado trecho de código é diretamente\nproporcional à <a href=\"https://pt.wikipedia.org/wiki/%C3%81rvore_de_decis%C3%A3o\">árvore decisória</a>.\nO que em outras palavras, quanto mais caminhos de código puder tomar (seja por meios de condicionais ou loops),\nmaior a quantidade de testes necessários. Abaixo veremos que há uma relação direta entre a <strong>complexidade ciclomática</strong>\ne a cobertura de um código.</p>\n<h3>Calculando a complexidade ciclomática</h3>\n<p>Um exemplo:\nSupondo que você esteja desenvolvendo um programa que lhe retorne o maior divisor comum entre dois números. Uma fórmula\nsimples é o <a href=\"https://pt.wikipedia.org/wiki/Algoritmo_de_Euclides\">Algoritmo de Euclides</a> que pode ser descrito da seguinte forma:</p>\n<blockquote>\n<p>Dados dois números naturais a e b, verifique se b é zero. Se sim, a é o maior divisor comum entre os mesmos; caso contrário, repita o processo usando b e o resto da divisão de a por b.</p>\n</blockquote>\n<p>Esse algoritmo pode ser expresso pelo seguinte programa em Ruby (note que ele não está em Ruby idiomático):</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">\"test/unit\"</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">euclid</span></span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">if</span> n <span class=\"token operator\">></span> m\n    r <span class=\"token operator\">=</span> m\n    m <span class=\"token operator\">=</span> n\n    n <span class=\"token operator\">=</span> r\n  <span class=\"token keyword\">end</span>\n  r <span class=\"token operator\">=</span> m <span class=\"token operator\">%</span> n\n  <span class=\"token keyword\">while</span> r <span class=\"token operator\">!=</span> <span class=\"token number\">0</span>\n    m <span class=\"token operator\">=</span> n\n    n <span class=\"token operator\">=</span> r\n    r <span class=\"token operator\">=</span> m <span class=\"token operator\">%</span> n\n  <span class=\"token keyword\">end</span>\n  n\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">EuclidTest</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Test</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Unit</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">TestCase</span>\n  \n  <span class=\"token constant\">SETS</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">5</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">6</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">11</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">7</span><span class=\"token punctuation\">,</span>  <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> \n    <span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">,</span> <span class=\"token number\">64</span><span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>\n  \n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_euclid</span></span>\n    <span class=\"token constant\">SETS</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token keyword\">do</span> <span class=\"token operator\">|</span>set<span class=\"token operator\">|</span>\n      assert_equal set<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> euclid<span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> set<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n  \n<span class=\"token keyword\">end</span></code></pre></div>\n<p>Se o programa acima for executado, ele rodará o caso de teste logo abaixo da função que verificará se a mesma está correta. Você pode adicionar mais casos ao conjunto SETS se desejar.</p>\n<p>A função euclid pode ser descrita por um grafo simples que conecta os caminhos entre as várias declarações que a mesma contém. Esse grafo é o mostrado abaixo (clique para expandir):</p>\n<p><img src=\"/grafo1.png\" alt=\"Grafo\"></p>\n<p>Com base nesse grafo, podemos definir a complexidade ciclomática de um programa da seguinte forma:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">CC</span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">-</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span>C</code></pre></div>\n<p>Nessa fórmula:</p>\n<ul>\n<li>CC é a complexidade ciclomática</li>\n<li>A é o número de arestas do grafo</li>\n<li>N é o número de nós do grafo</li>\n<li>C é o número de componentes conectados</li>\n</ul>\n<p>Como se trata de uma função simples com um único ponto de entrada e saída, o número de componentes é 1 e a fórmula pode ser reduzida para:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">CC</span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">-</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span></code></pre></div>\n<p>Se a função possuísse múltiplos pontos de saída, entretanto, a complexidade ciclomática seria definida como:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">CC</span> <span class=\"token operator\">=</span> <span class=\"token constant\">A</span> <span class=\"token operator\">-</span> <span class=\"token constant\">N</span> <span class=\"token operator\">+</span> <span class=\"token constant\">C</span> <span class=\"token operator\">+</span> <span class=\"token constant\">R</span></code></pre></div>\n<p>Nessa fórmula, R é o número de declarações de saída (em Ruby, o número de returns).</p>\n<p>Voltando ao grafo mostra na figura, vemos que o mesmo possui 11 nós e 12 arestas, o que nós dá uma complexidade ciclomática de <strong>12 - 11 + 2</strong>, ou seja, <strong>3</strong>.</p>\n<p>Uma outra maneira bem simples de descobrir a complexidade ciclomática é contar o número de loops fechados no grafo (que são formados por condicionais e loops) e somar ao número de pontos de saída. No grafo acima, temos 2 loops fechados (os if e while) e um ponto de saída, resultando no mesmo valor <strong>3</strong> para a complexidade da função.</p>\n<h3>Decomposição</h3>\n<p><img src=\"/grafo3.png\" alt=\"Grafo\"></p>\n<p>Uma segunda simplificação do cálculo de <strong>A - N + 2C</strong> reduz o cálculo de inspeção visual\ndo grafo de controle. Nós vamos precisar da formula de Euler na qual:</p>\n<blockquote>\n<p>Se G é um grafo plano conexo com N vértices, A arestas e R regiões, então <strong>N - A + R = 2</strong>.</p>\n</blockquote>\n<p>Apenas mudando a ordem dos termos, logo temos <strong>R = A - N + 2</strong>, então <strong>o numero de regiões\nou (faces do grafo) = complexidade ciclomática</strong>.</p>\n<hr>\n<p>A complexidade permanece a mesma quando a sintaxe de uma linguagem é levada em questão sem alterar a semântica do programa. Tome por exemplo a versão idiomática do algoritmo em Ruby:</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">euclid</span></span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span>\n  m<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> m <span class=\"token keyword\">if</span> n <span class=\"token operator\">></span> m\n  m<span class=\"token punctuation\">,</span> n <span class=\"token operator\">=</span> n<span class=\"token punctuation\">,</span> m <span class=\"token operator\">%</span> n <span class=\"token keyword\">while</span> m <span class=\"token operator\">%</span> n <span class=\"token operator\">!=</span> <span class=\"token number\">0</span>\n  n\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>O grafo gerado nesse caso é (clique para expandir):</p>\n<p><img src=\"/grafo2.png\" alt=\"Grafo\"></p>\n<p><sub><em>Note que embora o número de nós e arestas tenha mudado, a relação entre eles não mudou e a complexidade permanece a mesma.</em></sub></p>\n<h3>Testando</h3>\n<p>De uma forma geral, o valor da complexidade ciclomática define um limite superior para a quantidade de testes necessários para cobrir todos os caminhos decisórios no código em questão. Esse é um limite superior já que nem todos os caminhos são necessariamente realizáveis.</p>\n<p>Disso se infere que quanto menor a complexidade, menor a quantidade de testes necessários <strong>para o método em questão</strong>. Esse fato implica em outro curioso: quebra um método em vários reduz a complexidade dos métodos mas aumenta a complexidade geral do código e, de forma geral, mantém a testabilidade do programa completo no mesmo nível.</p>\n<h3>Mas há um referêncial?</h3>\n<p>Já que a complexidade é um valor específico, é possível ter uma referência. Baseado no trabalho de McCabe, esses valores de referência são:</p>\n<ul>\n<li>1-10, métodos simples, sem muito risco</li>\n<li>11-20, métodos medianamente complexos, com risco moderado</li>\n<li>21-50, métodos complexos, com risco alto</li>\n<li>51 ou mais, métodos instáveis de altíssimo risco</li>\n</ul>\n<h3>Conclusão</h3>\n<p>Essa foi uma pequena introdução ao assunto com o objetivo de abrir o caminho para artigos posteriores mostrando ferramentas de apoio ao cálculo e monitoramento da complexidade ciclomática. Como de usual, sugestões e correções são bem vindos.</p>\n<hr>\n<p>Você pode saber mais sobre Complexidade Ciclomática no artigo de McCabe pela IEEE TRANSACTIONS ON SOFTWARE ENGINEERING, VOL. SE-2, NO.4, em dezembro de 1976, <a href=\"http://www.literateprogramming.com/mccabe.pdf\">aqui</a>.</p>","frontmatter":{"title":"Complexidade Ciclomática","date":"March 22, 2016","description":"Uma métrica de software usada para indicar a complexidade de um programa de computador."}},"previous":{"fields":{"slug":"/template-e-strategy/"},"frontmatter":{"title":"Template Method e Strategy"}},"next":{"fields":{"slug":"/imperativa-vs-funcional.md/"},"frontmatter":{"title":"Programação Imperativa vs Funcional"}}},"pageContext":{"id":"3bdfad95-35de-5975-a3e8-356b22b3ca7c","previousPostId":"aef6cdb9-6f64-59c6-8fc2-37da269a56eb","nextPostId":"1943fecc-c550-5284-997e-e861db9335d8"}},"staticQueryHashes":["2841359383","916993862"]}